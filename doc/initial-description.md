The project is describable as real-time collaborative editor for XML documents. Rather than represent XML as a linear buffer of characters, using a data structure that more closely represents the structure of XML (but excluding entity references and CDATA sections, since neither is useful in this context).

Implementation language of choice is probably Javascript, since aside from the assorted browsers there are [node.js](nodejs.org) and [XULRunner](https://developer.mozilla.org/en-US/docs/XULRunner), which are for servers and desktop applications respectively.

Node.js is designed for writing servers; there are facilities for handling concurrent incoming connections efficiently, and for handling HTTP requests in particular. Libraries exist, such as [socket.io](https://github.com/LearnBoost/socket.io) that handle the details of websocket automatically.

XULRunner is more or less the same concept applied to Gecko; it includes enough infrastructure to write desktop applications using Javascript and HTML, and to act generally like desktop apps rather than webapps in a window of their own. Which will require designing certain parts of the client to switch implementations depending on whether XULRunner or a browser is being used.

As may have been gathered, the system will have a client-server architecture: previous work on this kind of topic found that doing so introduces asymmetries that allow a more efficient implementation. It also reduces the problem of how instances of the application find one another to the already very much solved problem of them all finding one server. Doing that in a P2P manner is *certainly* beyond the scope of this project (though it raises some interesting questions).

Websocket ([wire protocol](http://tools.ietf.org/html/rfc6455), [API](http://dev.w3.org/html5/websockets/)) is a reasonable choice to base the protocol on, being fairly simple and message oriented. It also has the advantage that, since it uses HTTP in its handshake, it can be made to share a server with more conventional HTTP resources, and passes through firewalls much better. This in turn means I don't have to figure out a way to do bulk transfers inline without interrupting message flow, I can just serve them via HTTP.

On the side of things pertaining to the actual collaborative editing, relevant documents and implementations are harder to find. Most are concerned with linear buffers of text, not the trees that form XML. [One such paper](http://arxiv.org/abs/0710.1784) does use trees, but as an internal representation of the data being edited rather than because the data is a tree. At least one (briefly) production system, the ill-fated Google Wave, attempted to represent a subset of XML as a linear string containing some extremely complicated characters, and had the notion, shared with Etherpad, of annotations that can overlap and mark ranges of text with a key/value pair.

The algorithm used in Google Wave is described in [this document](http://wave-protocol.googlecode.com/hg/whitepapers/operational-transform/operational-transform.html) as a modification to the algorithm in a 1995 [paper](http://mirrors.ccs.neu.edu/MOO/papers/JupiterWin.ps). In order to maintain well-formedness of the document, the Wave server apparently rejected any attempted operations that would violate that restriction. It also was designed to encourage spreading the contents of what is presented as one document across what, from the perspective of the algorithm, is many documents (which weren't required to have an identifiable root element), probably for performance reasons.

At least one [paper](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.100.74&rep=rep1&type=pdf) exists on representing XML as a tree and doing the collaborative editing thing on it. [Another](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.9273&rep=rep1&type=pdf) notes that whilst representing the document as a tree and using a conventional linear buffer oriented algorithm on the children of each node improves performance (and allows representing XML), the split and join operations occasionally useful when editing--and which a WYSIWYG editor encourage the generation of--can only be implemented in a rather messy way, if at all.

I should probably make clear that I'm technically referring to [Etherpad Lite](http://github.com/pita/etherpad-lite) above; the original Etherpad is considered obsolete by the developers.

Regarding the usage of these systems, all I can say is that the easiest way to explain them to someone seems to be by getting them to *use* one. I'm not aware of much in the way of people writing about how these sorts of things are used. I do observe that "pastebin with editing" and "wiki (possibly with only one page)" are both common use cases for Etherpad, due to the lack of authentication requirements (on its own, Etherpad actually can't do any authentication or access control) and ease of creating a document with a specified name. Google Wave looked on the surface like an instant messenger with tree-structured conversations, and felt most natural being used as one, but since any part of any message was editable, with rich text formatting, worked fairly well for creating documents with a strongly hierarchical structure, and had features which didn't make sense **except** in a document editor. 