So, a quick rundown of what all these contribute to my mental formulation of Larus, or, more precisely, the parts that are actually to do with the actual collaborative editing part.

Some are there as blind alleys, for instance MUW-xmlcrdt-long is based on other work which, like it, appears to assume every client knows of every other client editing the same document--not unreasonable on its own--and also that nodes don't disappear without warning for indefinitely long periods, something which I would rather guard against. All considerations that human beings with feelings and drama constitute the userbase aside, consider someone taking a two week vacation whilst a document is being vigorously edited. Any operations necessary for acceptable performance (tree rebalancing, removing deleted objects) being held up if they forget to unadd themselves, would clearly be unacceptable (something similar is held up as an issue with collaboration software that uses locking to prevent conflicts).

Similarly, the undo feature described in that paper, whilst interesting, somewhat complicates matters. Given that with a history viewer available (and nearly every collaboration tool at least saves a string of snapshots) this is primarily a convenience for users not wanting to got to the trouble of manually constructing an operation which removes the effect of a prior operation, it should probably not be considered.

Probably one of the biggest influences on my conception of how Larus is to function are DSL-OtSgml and a similar paper apparently by the same authors DSL-CoXml, laying out how to represent tree structures of the kind that XML is (roughly. SGML as intended is a different beast to XML as used), and deal with making them converge. It also threatened me with less complexity, or at least laying it out in a way that can be followed easily. Like the preceding one, it assumes every client knows of every other client in order to collect garbage, but raises the interesting point that the existence of trees not hanging off the root element could be used to implement cut and paste, something I disagree with: cut and paste is better done as a single atomic operation (think how Windows Explorer uses that as a metaphor for issuing effectively atomic move calls). Interestingly, DSL-CoXml agrees with this, proposing an operation by which one may move an element.

I personally don't think that move-one-element goes far enough. In some scenarios, one may wish to move a run of text and the elements in the middle of it (think relocating a sentence containing a link, for instance). The obvious way to support this is to make /individual characters/ be tree nodes, which has a certain conceptual elegance but will require a rather low-overhead way of addressing the tree nodes. 

That "every client knowing of every other" thing can be excised if one takes note of NCDL-jupiterwin, which is reiterated with a description of an interesting coercion of XML into a linear rich text buffer in WML-waveot, which lays out the train of thought by which a central server can eliminate the need for that: If all clients connect only to the server, the concurrency algorithm can be used with just two peers, where the operations contributed by the server are the edits received from other clients, and at that point one can arrange that the server doesn't even have to keep track of client state in any significant way, also laid out in the paper.

This is a really big deal because a) it means the server is now bottlenecked by responding to incoming operations and sending the results out, and b) if it's not tracking client state clients can come and go without other clients needing to care. The users of those clients will, but that need can be served some other way. Plus, so much less needs to be kept track of that the server and client are much simpler. Leaving the developer with more marbles to devote to things like the user wandering out of range of the wifi hotspot or kicking out the network cable, both of which interrupt network service and don't necessarily tell the application.

Oh, and making it so that the system as a whole is resistant to people who want to delete things or take their server and go home.